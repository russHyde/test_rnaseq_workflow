import pandas as pd
import yaml
from os.path import join

from snakemake.utils import min_version
from snakemake.utils import validate

# validate requires snakemake >= 5.1
# `conda activate` requires snakemake >= 5.4.3
min_version("5.4.3")

###############################################################################

# -- helper functions

def read_table_and_set_index(filepath, index_columns):
    table = pd.read_csv(
        filepath, sep = "\t", comment = "#"
    ).set_index(
        index_columns, drop = False
    )
    table.index = table.index.set_levels(
        [i.astype(str) for i in table.index.levels]
    )
    return table


# Functions specific to the `filter_and_align` workflow
# - eg, `get_filter_and_align_reports` to define all qc-reports for this
# workflow
include: "scripts/snake_workflow_functions/filter_and_align_functions.smk"

###############################################################################

# -- configuration

# ---- global snakemake config

validate(config, "conf_schemas/snake_config.schema.yaml")

# ---- definition of samples for study here

sequencing_samples = read_table_and_set_index(
    filepath=config["sequencing_samples"],
    index_columns=["study_id", "sample_id", "run_id", "lane_id"]
)
validate(
    sequencing_samples, "conf_schemas/sequencing_samples.schema.yaml"
)

# ---- definition of command line params for the programs used here

program_params = yaml.safe_load(
    open(config["program_params"], "r")
)
validate(
    program_params, "conf_schemas/program_params.schema.yaml"
)

# ---- definition of the transcriptome / genome reference used here

reference_params = yaml.safe_load(
    open(config["reference_params"], "r")
)
validate(
    reference_params, "conf_schemas/reference_params.schema.yaml"
)

###############################################################################

# -- data directories

job_dir = join("data", "job")

read_dirs = {
    "prefix": join(job_dir, "reads"),
    "raw" : join(job_dir, "reads", "raw_fastqs"),
    "trimmed": join(job_dir, "reads", "trimmed_fastqs")
}

qc_dirs = {
  "fastqc": {
    "prefix": join(job_dir, "fastqc"),
    "raw": join(job_dir, "fastqc", "raw_fastqs"),
    "trimmed": join(job_dir, "fastqc", "trimmed_fastqs")
  },
  "rseqc": {
    "prefix": join(job_dir, "rseqc")
  },
  "multiqc": {
    "prefix": join(job_dir, "multiqc")
  }
}

align_dirs = {
    "prefix": join(job_dir, "align"),
    "initial": join(job_dir, "align", "initial"),
    "coordsort": join(job_dir, "align", "coordsort"),
    "merge": join(job_dir, "align", "merge"),
    "markdup": join(job_dir, "align", "markdup"),
    "querysort": join(job_dir, "align", "querysort")
}

quantify_dirs = {
    "input": align_dirs["querysort"],
    "with_dups": join(job_dir, "quantify", "with_duplicates"),
    "without_dups": join(job_dir, "quantify", "without_duplicates"),
    "with_multimaps": join(job_dir, "quantify", "with_multimaps")
}

# -- required files

# This ensures that the feature-counts for each sequencing sample on each lane
# are obtained:

feature_counts_files = expand(
    join(
        "{directory_prefix}", "{unit.study_id}", "{unit.sample_id}",
        "{unit.run_id}.fcount.short"
    ),
    directory_prefix=[
        quantify_dirs[k] for k in ["with_dups", "without_dups", "with_multimaps"]
    ],
    unit=sequencing_samples.itertuples()
)

annotation_files = [
    os.path.join(job_dir, "annotations", "ensembl_gene_details.tsv")
]

# Make a cutadapt report for each (sample, run, lane)
# Make a fastqc report for both raw and trimmed fastq files from each
#   (sample, run, lane, read direction)

qc_reports = get_filter_and_align_reports(
    sequencing_samples=sequencing_samples,
    # cutadapt reports for trimming reads
    read_dirs=read_dirs,
    # fastqc reports for raw reads and trimmed reads
    fastqc_dirs=qc_dirs["fastqc"],
    # hisat2 and markDuplicates reports for aligned samples
    align_dirs=align_dirs,
    # featureCounts reports for aligned samples
    # - TODO: separate with_dups, without_dups and with_multimaps reports
    quantify_dirs=quantify_dirs,
    # rseqc reports (gene_body_coverage)
    rseqc_dirs=qc_dirs["rseqc"]
)

# A QC report that combines all single-sample QC reports
# - we could alternatively have made this report within the `qc` substep of
# this workflow, but that would require defining all qc-report-files that are
# generated by this substep again (and lead to lots of duplication).

multiqc_report = os.path.join(
    qc_dirs["multiqc"]["prefix"], "filter_and_align.html"
)

# ---- final list of required files

required_files = \
    feature_counts_files + \
    annotation_files + \
    qc_reports + \
    [multiqc_report]

###############################################################################

# -- rules

rule all:
    input:
        required_files

rule fake_trimming_and_alignment_report:
    input:
        required_files
    output:
        "doc/fake_report.pdf"
    shell:
        "touch {output}"

# -- rule-defining scripts

include: "scripts/snake_recipes/access_raw_reads.smk"
include: "scripts/snake_recipes/trim_cutadapt.smk"
include: "scripts/snake_recipes/align_hisat2.smk"
include: "scripts/snake_recipes/quantify_subread.smk"
include: "scripts/snake_recipes/quality_fastqc.smk"
include: "scripts/snake_recipes/quality_multiqc.smk"

include: "scripts/snake_recipes/coordsort_picard.smk"
include: "scripts/snake_recipes/querysort_picard.smk"
include: "scripts/snake_recipes/mergesam_picard.smk"
include: "scripts/snake_recipes/markduplicates_picard.smk"

# -- local rules

rule ensembl_gene_details:
    message:
        """
        --- Extract gene-information from ensembl database and ensembl gtf: GC
            content, gene-type etc
        """

    input:
        gtf = reference_params["annotation"]

    output:
        tsv = os.path.join(
            job_dir, "annotations", "ensembl_gene_details.tsv"
        )

    params:
        ensembl_version = reference_params["annotation_version"],
        ensembl_dataset = reference_params["biomart_dataset"]

    script:
        "scripts/snake_recipes/get_ensembl_gene_details.smk.R"
